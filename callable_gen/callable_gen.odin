package callable_gen
import  "core:fmt"

p := []string{"a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8"}
P := []string{"A1", "A2", "A3", "A4", "A5", "A6", "A7", "A8"}
N := len(P)

// generate the following strings to stdout:
//      proc(A, B, C, ...) -> (D, E, ...)
//      proc($A, $B, $C, ...) -> (D, E, ...)
generate_proc_signature :: proc(parameters: int, returns: int, declare: bool) {
    fmt.printf("proc(")
    for i in 0..<parameters {
        if i > 0 { fmt.printf(",") }
        if declare { fmt.printf("$") }
        fmt.printf("%s", P[i])
    }
    fmt.printf(")")
    if returns > 0 {
        fmt.printf(" -> ")
        if returns > 1 { fmt.printf("(") }
        for i in 0..<returns {
            if i > 0 { fmt.printf(",") }
            if declare { fmt.printf("$") }
            fmt.printf("%s", P[parameters + i])
        }
        if returns > 1 { fmt.printf(")") }
    }
}

generate_proc_return :: proc(parameters: int, returns: int) {
    if returns == 0 { return }
    fmt.printf(" -> ")
    if returns > 1 { fmt.printf("(") }
    for i in 0..<returns {
        if i > 0 { fmt.printf(",") }
        fmt.printf("%s", P[i + parameters])
    }
    if returns > 1 { fmt.printf(")") }
}

// generate the followingish:
//      Tuple4(proc(A, B, C), A, B, C)
//      Tuple4(proc($A, $B, $C) -> ($D, $E), A, B, C)
generate_tuple_signature :: proc(parameters: int, returns: int, declare: bool) {
    fmt.printf("Tuple%d(", parameters + 1)
    generate_proc_signature(parameters, returns, declare)
    for i in 0..<parameters { fmt.printf(",%s", P[i]) }
    fmt.printf(")")
}

// generate something like the following:
//      make_callable2 :: proc(procedure: proc($A, $B), a: A, b: B) -> Tuple3(proc(A, B), A, B) {
//          callable: Tuple3(proc(A, B), A, B)
//          make_tuple(&callable, procedure, a, b)
//          return callable
//      }
generate_make_callable :: proc(parameters: int, returns: int) {
    fmt.printf("make_callable_%d_%d :: proc(procedure:", parameters, returns)
    generate_proc_signature(parameters, returns, true)
    for i in 0..<parameters { fmt.printf(",%s:%s", p[i], P[i]) }
    fmt.printf(") -> ")
    generate_tuple_signature(parameters, returns, false)
    fmt.printf(" {{\n")
    fmt.printf("\tcallable: ")
    generate_tuple_signature(parameters, returns, false)
    fmt.printf("\n")
    fmt.printf("\tmake_tuple(&callable, procedure")
    for i in 0..<parameters { fmt.printf(",%s", p[i]) }
    fmt.printf(")\n")
    fmt.printf("\treturn callable\n")
    fmt.printf("}}\n")
}

// generate something like the following:
//    call1_default  :: proc(tuple: ^Tuple2(proc($A), A)) {
//      call1_override(tuple, PASS)
//    }
generate_call_default :: proc(parameters: int, returns: int) {
    if parameters == 0 { return }
    fmt.printf("call_%d_%d_default :: proc(tuple: ^", parameters, returns)
    generate_tuple_signature(parameters, returns, true)
    fmt.printf(")")
    generate_proc_return(parameters, returns)
    fmt.printf(" {{\n")
    fmt.printf("\t")
    if returns > 0 { fmt.printf("return ") }
    fmt.printf("call_%d_%d_override(tuple", parameters, returns)
    for i in 0..<parameters { fmt.printf(",PASS") }
    fmt.printf(")\n")
    fmt.printf("}}\n")
}

// generate something like the following:
//    call1_override :: proc(tuple: ^Tuple2(proc($A), A), a: union{A, Pass_Enum}) {
//      a := a.(A) or_else tuple_get1(tuple)
//      tuple_get0(tuple)(a)
//    }
generate_call_override :: proc(parameters: int, returns: int) {
    fmt.printf("call_%d_%d_override :: proc(tuple: ^", parameters, returns)
    generate_tuple_signature(parameters, returns, true)
    for i in 0..<parameters { fmt.printf(",%s:union{{%s,Pass_Enum}}", p[i], P[i]) }
    fmt.printf(")")
    generate_proc_return(parameters, returns)
    fmt.printf(" {{\n")
    for i in 0..<parameters {
        fmt.printf("\t%s := %s.(%s) or_else tuple_get%d(tuple)\n", p[i], p[i], P[i], i + 1)
    }
    fmt.printf("\t")
    if returns > 0 { fmt.printf("return ") }
    fmt.printf("tuple_get0(tuple)(")
    for i in 0..<parameters {
        if i > 0 { fmt.printf(",") }
        fmt.printf("%s", p[i])
    }
    fmt.printf(")\n")
    fmt.printf("}}\n")
}

main :: proc() {
    fmt.printf("// THIS FILE IS GENERATED BY callable_gen/callable_gen.odin\n\n")
    fmt.printf("package callable\n\n")
    fmt.printf("Pass_Enum :: enum {{Pass}}\nPASS :: Pass_Enum.Pass\n\n")
    for returns in 0..=N {
        for parameters in 0..=(N-returns) {
             generate_make_callable(parameters, returns)
             generate_call_default(parameters, returns)
             generate_call_override(parameters, returns)
             fmt.println()
        }
    }
    fmt.printf("\n")

    fmt.printf("make_callable :: proc{{")
    for returns in 0..=N {
        for parameters in 0..=(N-returns) {
             fmt.printf("make_callable_%d_%d,", parameters, returns)
        }
    }
    fmt.printf("}}\n\n")

    fmt.printf("call :: proc{{")
    for returns in 0..=N {
        for parameters in 0..=(N-returns) {
            if parameters > 0 {
                fmt.printf("call_%d_%d_default,", parameters, returns)
            }
            fmt.printf("call_%d_%d_override,", parameters, returns)
        }
    }
    fmt.printf("}}\n")
}
